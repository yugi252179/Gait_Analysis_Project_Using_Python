<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corrected AI Gait Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@2.2.2/dist/posenet.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container {
            max-width: 800px;
        }
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        .result-card {
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 0.75rem;
            color: white;
        }
        .result-card h3 {
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 0.5rem;
        }
        .error-message {
             background-color: #fef2f2; /* Red-50 */
             color: #991b1b; /* Red-800 */
             padding: 1rem;
             border-radius: 0.75rem;
             border: 1px solid #fca5a5; /* Red-300 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="container bg-white shadow-xl rounded-2xl overflow-hidden p-8 space-y-8">
        <header class="text-center">
            <h1 class="text-3xl font-bold text-gray-800">Corrected AI Gait Analysis üèÉ‚Äç‚ôÇÔ∏è</h1>
            <p class="mt-2 text-gray-500">Upload a video to get detailed insights into your walk.</p>
        </header>

        <section class="upload-section text-center p-6 border-2 border-dashed border-gray-300 rounded-xl">
            <h2 class="text-xl font-semibold text-gray-700">Upload Video</h2>
            <p class="text-sm text-gray-400 mt-2">.mp4, .mov, or .webm format</p>
            <input type="file" id="video-upload" accept="video/*" class="mt-4 p-2 w-full border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
        </section>

        <section class="video-preview-section hidden mt-8">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Video Preview & Analysis</h2>
            <div class="relative w-full rounded-xl overflow-hidden shadow-lg bg-black">
                <video id="video-preview" controls class="w-full" muted playsinline></video>
                <canvas id="pose-canvas" class="absolute top-0 left-0 w-full h-full"></canvas>
            </div>
            <div id="loading-spinner" class="hidden text-center mt-4">
                <div class="inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-current border-r-transparent align-[-0.125em] text-blue-500 motion-reduce:animate-[spin_1.5s_linear_infinite]" role="status">
                    <span class="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">Loading...</span>
                </div>
                <p class="mt-2 text-sm text-gray-600">Analyzing video frames...</p>
            </div>
            <button id="analyze-btn" class="mt-4 w-full bg-blue-600 text-white font-semibold py-3 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors">Start Analysis</button>
        </section>

        <section class="results-section hidden mt-8">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Analysis Results üìä</h2>
            <div id="results-output" class="bg-gray-900 text-white p-4 rounded-xl text-sm overflow-x-auto whitespace-pre-wrap"></div>
        </section>
    </div>

    <script>
        const videoUpload = document.getElementById('video-upload');
        const videoPreviewSection = document.querySelector('.video-preview-section');
        const videoPreview = document.getElementById('video-preview');
        const analyzeBtn = document.getElementById('analyze-btn');
        const loadingSpinner = document.getElementById('loading-spinner');
        const resultsSection = document.querySelector('.results-section');
        const resultsOutput = document.getElementById('results-output');
        const poseCanvas = document.getElementById('pose-canvas');
        const canvasCtx = poseCanvas.getContext('2d');
        let animationFrameId;

        function displayMessage(message) {
            const messageBox = document.createElement('div');
            messageBox.className = "fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-50";
            messageBox.innerHTML = `
                <div class="bg-white p-8 rounded-xl shadow-lg text-center max-w-sm">
                    <p class="text-gray-800 text-lg mb-4">${message}</p>
                    <button class="bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">OK</button>
                </div>
            `;
            document.body.appendChild(messageBox);
            messageBox.querySelector('button').addEventListener('click', () => { document.body.removeChild(messageBox); });
        }

        function drawKeypoints(keypoints, minConfidence, ctx) {
            for (const keypoint of keypoints) {
                if (keypoint.score > minConfidence) {
                    const { y, x } = keypoint.position;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = '#34d399';
                    ctx.fill();
                }
            }
        }

        function drawSkeleton(keypoints, minConfidence, ctx) {
            const adjacentKeyPoints = posenet.getAdjacentKeyPoints(keypoints, minConfidence);
            adjacentKeyPoints.forEach((pair) => {
                const [start, end] = pair;
                ctx.beginPath();
                ctx.moveTo(start.position.x, start.position.y);
                ctx.lineTo(end.position.x, end.position.y);
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#60a5fa';
                ctx.stroke();
            });
        }

        videoUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const videoURL = URL.createObjectURL(file);
                videoPreview.src = videoURL;
                videoPreviewSection.classList.remove('hidden');
                resultsSection.classList.add('hidden');
                resultsOutput.innerHTML = '';
                canvasCtx.clearRect(0, 0, poseCanvas.width, poseCanvas.height);
            }
        });

        analyzeBtn.addEventListener('click', async () => {
            if (!videoPreview.src || videoPreview.readyState < 2) {
                displayMessage('Please upload a video and wait for it to load.');
                return;
            }

            // **CORRECTION 1: Check video duration before starting analysis**
            if (videoPreview.duration < 2) {
                 displayMessage('Video is too short. Please use a video that is at least 2 seconds long.');
                 return;
            }

            loadingSpinner.classList.remove('hidden');
            resultsSection.classList.add('hidden');
            analyzeBtn.disabled = true;
            analyzeBtn.textContent = 'Analyzing...';
            resultsOutput.innerHTML = '';

            const video = videoPreview;
            const model = await posenet.load({ architecture: 'MobileNetV1', outputStride: 16, multiplier: 0.75 });
            
            const allPoses = [];
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            video.currentTime = 0;
            video.play();
            
            const processFrame = async () => {
                const pose = await model.estimateSinglePose(video, { flipHorizontal: false });
                allPoses.push(pose);
                
                poseCanvas.width = video.videoWidth;
                poseCanvas.height = video.videoHeight;
                canvasCtx.clearRect(0, 0, poseCanvas.width, poseCanvas.height);
                
                if (pose && pose.keypoints) {
                    drawKeypoints(pose.keypoints, 0.5, canvasCtx);
                    drawSkeleton(pose.keypoints, 0.5, canvasCtx);
                }

                if (!video.paused && !video.ended) {
                    animationFrameId = requestAnimationFrame(processFrame);
                }
            };
            
            animationFrameId = requestAnimationFrame(processFrame);

            video.onended = () => {
                cancelAnimationFrame(animationFrameId);
                loadingSpinner.classList.add('hidden');
                resultsSection.classList.remove('hidden');
                analyzeBtn.disabled = false;
                analyzeBtn.textContent = 'Start Analysis';

                // **CORRECTION 2: Check for VALID poses, not just total frames**
                const minConfidence = 0.5;
                const validPoses = allPoses.filter(pose => 
                    pose.keypoints.find(kp => kp.part === 'leftAnkle' && kp.score > minConfidence) &&
                    pose.keypoints.find(kp => kp.part === 'rightAnkle' && kp.score > minConfidence)
                );
                
                const MIN_VALID_FRAMES = 10;
                if (validPoses.length > MIN_VALID_FRAMES) {
                    calculateAndDisplayGaitMetrics(validPoses, video.duration);
                } else {
                    // **CORRECTION 3: Provide a more specific error message**
                    resultsOutput.innerHTML = `
                        <div class="error-message">
                            <h3 class="font-bold">Analysis Failed: Subject Not Clearly Visible</h3>
                            <p class="mt-2">The AI could not reliably detect the person's joints in the video.</p>
                            <p class="mt-2"><strong>Please try again with a new video:</strong></p>
                            <ul class="list-disc list-inside mt-1">
                                <li>Film the person from the side.</li>
                                <li>Make sure the full body (head to toe) is in the frame.</li>
                                <li>Use bright, even lighting with a clear background.</li>
                            </ul>
                        </div>
                    `;
                }
            };
        });

        function calculateAndDisplayGaitMetrics(poses, duration) {
            const keypoints = poses.map(p => p.keypoints);
            
            const getKeypoint = (frame, part) => frame.find(kp => kp.part === part);

            let steps = 0;
            const leftAnkleY = keypoints.map(kps => getKeypoint(kps, 'leftAnkle')?.position.y);
            for(let i = 1; i < leftAnkleY.length - 1; i++){
                if (leftAnkleY[i] > leftAnkleY[i-1] && leftAnkleY[i] > leftAnkleY[i+1]) {
                    steps++;
                }
            }
            const cadence = (steps / duration) * 60;
            const strideTime = duration / steps * 2;

            const calculateAngle = (p1, p2, p3) => {
                if(!p1 || !p2 || !p3) return null;
                const a = Math.hypot(p2.position.x - p3.position.x, p2.position.y - p3.position.y);
                const b = Math.hypot(p1.position.x - p3.position.x, p1.position.y - p3.position.y);
                const c = Math.hypot(p1.position.x - p2.position.x, p1.position.y - p2.position.y);
                const angleRad = Math.acos((a*a + c*c - b*b) / (2 * a * c));
                return angleRad * (180 / Math.PI);
            };

            const metrics = { leftKnee: [], rightKnee: [], leftHip: [], rightHip: [] };

            for (const frame of keypoints) {
                const lHip = getKeypoint(frame, 'leftHip'), lKnee = getKeypoint(frame, 'leftKnee'), lAnkle = getKeypoint(frame, 'leftAnkle'), lShoulder = getKeypoint(frame, 'leftShoulder');
                const rHip = getKeypoint(frame, 'rightHip'), rKnee = getKeypoint(frame, 'rightKnee'), rAnkle = getKeypoint(frame, 'rightAnkle'), rShoulder = getKeypoint(frame, 'rightShoulder');
                metrics.leftKnee.push(calculateAngle(lHip, lKnee, lAnkle));
                metrics.rightKnee.push(calculateAngle(rHip, rKnee, rAnkle));
                metrics.leftHip.push(calculateAngle(lShoulder, lHip, lKnee));
                metrics.rightHip.push(calculateAngle(rShoulder, rHip, rKnee));
            }
            
            const getStats = (arr) => {
                const validValues = arr.filter(v => v !== null && !isNaN(v));
                if (validValues.length === 0) return { avg: 'N/A', max: 'N/A' };
                const sum = validValues.reduce((a, b) => a + b, 0);
                const avg = sum / validValues.length;
                const max = Math.max(...validValues);
                return { avg: avg.toFixed(1), max: max.toFixed(1) };
            };
            
            const leftKneeStats = getStats(metrics.leftKnee), rightKneeStats = getStats(metrics.rightKnee), leftHipStats = getStats(metrics.leftHip), rightHipStats = getStats(metrics.rightHip);

            resultsOutput.innerHTML = `
                <div class="results-grid">
                    <div class="result-card">
                        <h3>Pace & Rhythm</h3>
                        <p><strong>Cadence:</strong> ${cadence.toFixed(0)} steps/min</p>
                        <p><strong>Avg. Stride Time:</strong> ${isFinite(strideTime) ? strideTime.toFixed(2) + ' s' : 'N/A'}</p>
                    </div>
                    <div class="result-card">
                        <h3>Knee Angles</h3>
                        <p><strong>Left (Avg/Peak):</strong> ${leftKneeStats.avg}¬∞ / ${leftKneeStats.max}¬∞</p>
                        <p><strong>Right (Avg/Peak):</strong> ${rightKneeStats.avg}¬∞ / ${rightKneeStats.max}¬∞</p>
                    </div>
                     <div class="result-card">
                        <h3>Hip Angles</h3>
                        <p><strong>Left (Avg/Peak):</strong> ${leftHipStats.avg}¬∞ / ${leftHipStats.max}¬∞</p>
                        <p><strong>Right (Avg/Peak):</strong> ${rightHipStats.avg}¬∞ / ${rightHipStats.max}¬∞</p>
                    </div>
                </div>
            `;
        }
    </script>
</body>
</html>